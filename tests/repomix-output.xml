This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
fixtures/
  config_with_custom_lang.yaml
  empty_config.yaml
  example.py
  invalid_config_empty.yaml
  invalid_config_extensions.yaml
  invalid_config_not_dict.yaml
  invalid_config_yaml_error.yaml
  README_ENHANCED.md
  valid_config.yaml
README_ENHANCED.md
test_integration.py
test_unit.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="fixtures/config_with_custom_lang.yaml">
# Config with custom languages for testing get_supported_languages
customLanguages:
  customlang1:
    extensions:
      - .custom1
  customlang2:
    extensions:
      - .custom2
</file>

<file path="fixtures/empty_config.yaml">
# Empty file - just comments
</file>

<file path="fixtures/example.py">
def hello():
    print("Hello, World!")


def add(a, b):
    return a + b


class Calculator:
    def multiply(self, x, y):
        return x * y
</file>

<file path="fixtures/invalid_config_empty.yaml">
# Invalid config - empty lists
ruleDirs: []
customLanguages: {}
</file>

<file path="fixtures/invalid_config_extensions.yaml">
# Invalid config - extensions without dots
customLanguages:
  badlang:
    extensions:
      - txt  # Should be .txt
      - md   # Should be .md
</file>

<file path="fixtures/invalid_config_not_dict.yaml">
- this
- is
- a
- list
- not
- a
- dict
</file>

<file path="fixtures/invalid_config_yaml_error.yaml">
# Invalid YAML - syntax error
ruleDirs:
  - rules
  - missing quote: "unclosed
</file>

<file path="fixtures/README_ENHANCED.md">
# fixtures

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "fixtures",
  "description": "Directory containing 1 code files with 1 classes and 2 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Python"
    }
  ],
  "featureList": [
    "1 class definitions",
    "2 function definitions"
  ]
}
</script>

## Overview

This directory contains 1 code file(s) with extracted schemas.

## Files and Schemas

### `example.py` (python)

**Classes:**
- `Calculator` - Line 9
  - Methods: multiply

**Functions:**
- `hello()` - Line 1
- `add(a, b)` - Line 5

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="fixtures/valid_config.yaml">
# Valid sgconfig.yaml for testing
ruleDirs:
  - rules
  - custom-rules

testDirs:
  - tests

customLanguages:
  mylang:
    extensions:
      - .ml
      - .mli
    languageId: mylang

  anotherlang:
    extensions:
      - .al

languageGlobs:
  - extensions: [.proto]
    language: protobuf
</file>

<file path="README_ENHANCED.md">
# tests

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "tests",
  "description": "Directory containing 2 code files with 19 classes and 3 functions",
  "programmingLanguage": [
    {
      "@type": "ComputerLanguage",
      "name": "Python"
    }
  ],
  "featureList": [
    "19 class definitions",
    "3 function definitions"
  ]
}
</script>

## Overview

This directory contains 2 code file(s) with extracted schemas.

## Subdirectories

- `fixtures/`

## Files and Schemas

### `test_integration.py` (python)

**Classes:**
- `MockFastMCP` - Line 15
  - Mock FastMCP that returns functions unchanged
  - Methods: __init__, tool, run
- `TestIntegration` - Line 61
  - Integration tests for ast-grep MCP functions
  - Methods: test_find_code_text_format, test_find_code_json_format, test_find_code_by_rule, test_find_code_with_max_results, test_find_code_no_matches

**Functions:**
- `mock_field()` - Line 38
- `fixtures_dir()` - Line 56

**Key Imports:** `json`, `main`, `os`, `pytest`, `sys` (+1 more)

### `test_unit.py` (python)

**Classes:**
- `MockFastMCP` - Line 16
  - Mock FastMCP that returns functions unchanged
  - Methods: __init__, tool, run
- `TestDumpSyntaxTree` - Line 63
  - Test the dump_syntax_tree function
  - Methods: test_dump_syntax_tree_cst, test_dump_syntax_tree_pattern
- `TestTestMatchCodeRule` - Line 96
  - Test the test_match_code_rule function
  - Methods: test_match_found, test_no_match
- `TestFindCode` - Line 138
  - Test the find_code function
  - Methods: test_text_format_with_results, test_text_format_no_results, test_text_format_with_max_results, test_json_format, test_json_format_with_max_results (+1 more)
- `TestFindCodeByRule` - Line 258
  - Test the find_code_by_rule function
  - Methods: test_text_format_with_results, test_json_format
- `TestRunCommand` - Line 317
  - Test the run_command function
  - Methods: test_successful_command, test_command_failure, test_command_not_found
- `TestFormatMatchesAsText` - Line 354
  - Test the format_matches_as_text helper function
  - Methods: test_empty_matches, test_single_line_match, test_multi_line_match, test_multiple_matches
- `TestRunAstGrep` - Line 405
  - Test the run_ast_grep function
  - Methods: test_without_config, test_with_config
- `TestConfigValidation` - Line 443
  - Test the validate_config_file function
  - Methods: test_valid_config, test_invalid_config_extensions, test_invalid_config_empty_lists, test_config_file_not_found, test_config_file_is_directory (+3 more)
- `TestGetSupportedLanguages` - Line 521
  - Test the get_supported_languages function
  - Methods: test_without_config, test_with_custom_languages, test_with_nonexistent_config, test_with_config_exception
- `TestCustomLanguageConfig` - Line 593
  - Test CustomLanguageConfig Pydantic model
  - Methods: test_empty_extensions_list, test_valid_extensions
- `TestFormatMatchesEdgeCases` - Line 616
  - Test edge cases for format_matches_as_text
  - Methods: test_missing_file_field, test_missing_range_field, test_missing_text_field
- `TestFindCodeEdgeCases` - Line 653
  - Test edge cases for find_code function
  - Methods: test_find_code_with_language, test_find_code_without_language
- `TestFindCodeByRuleEdgeCases` - Line 701
  - Test edge cases for find_code_by_rule function
  - Methods: test_find_code_by_rule_no_results_text, test_find_code_by_rule_invalid_yaml_syntax, test_find_code_by_rule_invalid_output_format, test_find_code_by_rule_yaml_not_dict, test_find_code_by_rule_missing_id (+3 more)
- `TestValidateConfigFileErrors` - Line 858
  - Test error paths in validate_config_file
  - Methods: test_config_file_read_error
- `TestYAMLValidation` - Line 872
  - Test YAML validation in tools
  - Methods: test_invalid_yaml_structure, test_missing_id_field, test_missing_language_field, test_missing_rule_field, test_yaml_syntax_error_in_test_match
- `TestParseArgsAndGetConfig` - Line 935
  - Test parse_args_and_get_config function
  - Methods: test_no_config_provided, test_with_valid_config_flag, test_with_env_var_config

**Functions:**
- `mock_field()` - Line 39

**Key Imports:** `importlib`, `json`, `main`, `os`, `pydantic` (+4 more)

---
*Generated by Enhanced Schema Generator with schema.org markup*
</file>

<file path="test_integration.py">
"""Integration tests for ast-grep MCP server"""

import json
import os
import sys
from unittest.mock import Mock, patch

import pytest

# Add parent directory to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


# Mock FastMCP to disable decoration
class MockFastMCP:
    """Mock FastMCP that returns functions unchanged"""

    def __init__(self, name):
        self.name = name
        self.tools = {}  # Store registered tools

    def tool(self, **kwargs):
        """Decorator that returns the function unchanged"""

        def decorator(func):
            # Store the function for later retrieval
            self.tools[func.__name__] = func
            return func  # Return original function without modification

        return decorator

    def run(self, **kwargs):
        """Mock run method"""
        pass


# Mock the Field function to return the default value
def mock_field(**kwargs):
    return kwargs.get("default")


# Import with mocked decorators
with patch("mcp.server.fastmcp.FastMCP", MockFastMCP):
    with patch("pydantic.Field", mock_field):
        import main

        # Call register_mcp_tools to define the tool functions
        main.register_mcp_tools()

        # Extract the tool functions from the mocked mcp instance
        find_code = main.mcp.tools.get("find_code")
        find_code_by_rule = main.mcp.tools.get("find_code_by_rule")


@pytest.fixture
def fixtures_dir():
    """Get the path to the fixtures directory"""
    return os.path.abspath(os.path.join(os.path.dirname(__file__), "fixtures"))


class TestIntegration:
    """Integration tests for ast-grep MCP functions"""

    def test_find_code_text_format(self, fixtures_dir):
        """Test find_code with text format"""
        result = find_code(
            project_folder=fixtures_dir,
            pattern="def $NAME($$$)",
            language="python",
            output_format="text",
        )

        assert "hello" in result
        assert "add" in result
        assert "Found" in result and "matches" in result

    def test_find_code_json_format(self, fixtures_dir):
        """Test find_code with JSON format"""
        result = find_code(
            project_folder=fixtures_dir,
            pattern="def $NAME($$$)",
            language="python",
            output_format="json",
        )

        assert len(result) >= 2
        assert any("hello" in str(match) for match in result)
        assert any("add" in str(match) for match in result)

    @patch("main.run_ast_grep")
    def test_find_code_by_rule(self, mock_run, fixtures_dir):
        """Test find_code_by_rule with mocked ast-grep"""
        # Mock the response with JSON format (since we always use JSON internally)
        mock_result = Mock()
        mock_matches = [{
            "text": "class Calculator:\n    pass",
            "file": "fixtures/example.py",
            "range": {"start": {"line": 6}, "end": {"line": 7}}
        }]
        mock_result.stdout = json.dumps(mock_matches)
        mock_run.return_value = mock_result

        yaml_rule = """id: test
language: python
rule:
  pattern: class $NAME"""

        result = find_code_by_rule(
            project_folder=fixtures_dir, yaml_rule=yaml_rule, output_format="text"
        )

        assert "Calculator" in result
        assert "Found 1 match" in result
        assert "fixtures/example.py:7-8" in result

        # Verify the command was called correctly
        mock_run.assert_called_once_with(
            "scan", ["--inline-rules", yaml_rule, "--json", fixtures_dir]
        )

    def test_find_code_with_max_results(self, fixtures_dir):
        """Test find_code with max_results parameter"""
        result = find_code(
            project_folder=fixtures_dir,
            pattern="def $NAME($$$)",
            language="python",
            max_results=1,
            output_format="text",
        )

        # The new format says "showing first X of Y" instead of "limited to X"
        assert "showing first 1 of" in result or "Found 1 match" in result
        # Should only have one match in the output
        assert result.count("def ") == 1

    def test_find_code_no_matches(self, fixtures_dir):
        """Test find_code when no matches are found"""
        result = find_code(
            project_folder=fixtures_dir,
            pattern="nonexistent_pattern_xyz",
            output_format="text",
        )

        assert result == "No matches found"
</file>

<file path="test_unit.py">
"""Unit tests for ast-grep MCP server"""

import json
import os
import subprocess
import sys
from unittest.mock import Mock, patch

import pytest

# Add the parent directory to the path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


# Mock FastMCP to disable decoration
class MockFastMCP:
    """Mock FastMCP that returns functions unchanged"""

    def __init__(self, name):
        self.name = name
        self.tools = {}  # Store registered tools

    def tool(self, **kwargs):
        """Decorator that returns the function unchanged"""

        def decorator(func):
            # Store the function for later retrieval
            self.tools[func.__name__] = func
            return func  # Return original function without modification

        return decorator

    def run(self, **kwargs):
        """Mock run method"""
        pass


# Mock the Field function to return the default value
def mock_field(**kwargs):
    return kwargs.get("default")


# Patch the imports before loading main
with patch("mcp.server.fastmcp.FastMCP", MockFastMCP):
    with patch("pydantic.Field", mock_field):
        import main
        from main import (
            format_matches_as_text,
            run_ast_grep,
            run_command,
        )

        # Call register_mcp_tools to define the tool functions
        main.register_mcp_tools()

        # Extract the tool functions from the mocked mcp instance
        dump_syntax_tree = main.mcp.tools.get("dump_syntax_tree")
        find_code = main.mcp.tools.get("find_code")
        find_code_by_rule = main.mcp.tools.get("find_code_by_rule")
        match_code_rule = main.mcp.tools.get("test_match_code_rule")


class TestDumpSyntaxTree:
    """Test the dump_syntax_tree function"""

    @patch("main.run_ast_grep")
    def test_dump_syntax_tree_cst(self, mock_run):
        """Test dumping CST format"""
        mock_result = Mock()
        mock_result.stderr = "ROOT@0..10"
        mock_run.return_value = mock_result

        result = dump_syntax_tree("const x = 1", "javascript", "cst")

        assert result == "ROOT@0..10"
        mock_run.assert_called_once_with(
            "run",
            ["--pattern", "const x = 1", "--lang", "javascript", "--debug-query=cst"],
        )

    @patch("main.run_ast_grep")
    def test_dump_syntax_tree_pattern(self, mock_run):
        """Test dumping pattern format"""
        mock_result = Mock()
        mock_result.stderr = "pattern_node"
        mock_run.return_value = mock_result

        result = dump_syntax_tree("$VAR", "python", "pattern")

        assert result == "pattern_node"
        mock_run.assert_called_once_with(
            "run", ["--pattern", "$VAR", "--lang", "python", "--debug-query=pattern"]
        )


class TestTestMatchCodeRule:
    """Test the test_match_code_rule function"""

    @patch("main.run_ast_grep")
    def test_match_found(self, mock_run):
        """Test when matches are found"""
        mock_result = Mock()
        mock_result.stdout = '[{"text": "def foo(): pass"}]'
        mock_run.return_value = mock_result

        yaml_rule = """id: test
language: python
rule:
  pattern: 'def $NAME(): $$$'
"""
        code = "def foo(): pass"

        result = match_code_rule(code, yaml_rule)

        assert result == [{"text": "def foo(): pass"}]
        mock_run.assert_called_once_with(
            "scan", ["--inline-rules", yaml_rule, "--json", "--stdin"], input_text=code
        )

    @patch("main.run_ast_grep")
    def test_no_match(self, mock_run):
        """Test when no matches are found"""
        mock_result = Mock()
        mock_result.stdout = "[]"
        mock_run.return_value = mock_result

        yaml_rule = """id: test
language: python
rule:
  pattern: 'class $NAME'
"""
        code = "def foo(): pass"

        with pytest.raises(main.NoMatchesError, match="No matches found"):
            match_code_rule(code, yaml_rule)


class TestFindCode:
    """Test the find_code function"""

    @patch("main.run_ast_grep")
    def test_text_format_with_results(self, mock_run):
        """Test text format output with results"""
        mock_result = Mock()
        mock_matches = [
            {"text": "def foo():\n    pass", "file": "file.py",
             "range": {"start": {"line": 0}, "end": {"line": 1}}},
            {"text": "def bar():\n    return", "file": "file.py",
             "range": {"start": {"line": 4}, "end": {"line": 5}}}
        ]
        mock_result.stdout = json.dumps(mock_matches)
        mock_run.return_value = mock_result

        result = find_code(
            project_folder="/test/path",
            pattern="def $NAME():",
            language="python",
            output_format="text",
        )

        assert "Found 2 matches:" in result
        assert "def foo():" in result
        assert "def bar():" in result
        assert "file.py:1-2" in result
        assert "file.py:5-6" in result
        mock_run.assert_called_once_with(
            "run", ["--pattern", "def $NAME():", "--lang", "python", "--json", "/test/path"]
        )

    @patch("main.run_ast_grep")
    def test_text_format_no_results(self, mock_run):
        """Test text format output with no results"""
        mock_result = Mock()
        mock_result.stdout = "[]"
        mock_run.return_value = mock_result

        result = find_code(
            project_folder="/test/path", pattern="nonexistent", output_format="text"
        )

        assert result == "No matches found"
        mock_run.assert_called_once_with(
            "run", ["--pattern", "nonexistent", "--json", "/test/path"]
        )

    @patch("main.run_ast_grep")
    def test_text_format_with_max_results(self, mock_run):
        """Test text format with max_results limit"""
        mock_result = Mock()
        mock_matches = [
            {"text": "match1", "file": "f.py", "range": {"start": {"line": 0}, "end": {"line": 0}}},
            {"text": "match2", "file": "f.py", "range": {"start": {"line": 1}, "end": {"line": 1}}},
            {"text": "match3", "file": "f.py", "range": {"start": {"line": 2}, "end": {"line": 2}}},
            {"text": "match4", "file": "f.py", "range": {"start": {"line": 3}, "end": {"line": 3}}},
        ]
        mock_result.stdout = json.dumps(mock_matches)
        mock_run.return_value = mock_result

        result = find_code(
            project_folder="/test/path",
            pattern="pattern",
            max_results=2,
            output_format="text",
        )

        assert "Found 2 matches (showing first 2 of 4):" in result
        assert "match1" in result
        assert "match2" in result
        assert "match3" not in result

    @patch("main.run_ast_grep")
    def test_json_format(self, mock_run):
        """Test JSON format output"""
        mock_result = Mock()
        mock_matches = [
            {"text": "def foo():", "file": "test.py"},
            {"text": "def bar():", "file": "test.py"},
        ]
        mock_result.stdout = json.dumps(mock_matches)
        mock_run.return_value = mock_result

        result = find_code(
            project_folder="/test/path", pattern="def $NAME():", output_format="json"
        )

        assert result == mock_matches
        mock_run.assert_called_once_with(
            "run", ["--pattern", "def $NAME():", "--json", "/test/path"]
        )

    @patch("main.run_ast_grep")
    def test_json_format_with_max_results(self, mock_run):
        """Test JSON format with max_results limit"""
        mock_result = Mock()
        mock_matches = [{"text": "match1"}, {"text": "match2"}, {"text": "match3"}]
        mock_result.stdout = json.dumps(mock_matches)
        mock_run.return_value = mock_result

        result = find_code(
            project_folder="/test/path",
            pattern="pattern",
            max_results=2,
            output_format="json",
        )

        assert len(result) == 2
        assert result[0]["text"] == "match1"
        assert result[1]["text"] == "match2"

    def test_invalid_output_format(self):
        """Test with invalid output format"""
        with pytest.raises(ValueError, match="Invalid output_format"):
            find_code(
                project_folder="/test/path", pattern="pattern", output_format="invalid"
            )


class TestFindCodeByRule:
    """Test the find_code_by_rule function"""

    @patch("main.run_ast_grep")
    def test_text_format_with_results(self, mock_run):
        """Test text format output with results"""
        mock_result = Mock()
        mock_matches = [
            {"text": "class Foo:\n    pass", "file": "file.py",
             "range": {"start": {"line": 0}, "end": {"line": 1}}},
            {"text": "class Bar:\n    pass", "file": "file.py",
             "range": {"start": {"line": 9}, "end": {"line": 10}}}
        ]
        mock_result.stdout = json.dumps(mock_matches)
        mock_run.return_value = mock_result

        yaml_rule = """id: test
language: python
rule:
  pattern: 'class $NAME'
"""

        result = find_code_by_rule(
            project_folder="/test/path", yaml_rule=yaml_rule, output_format="text"
        )

        assert "Found 2 matches:" in result
        assert "class Foo:" in result
        assert "class Bar:" in result
        assert "file.py:1-2" in result
        assert "file.py:10-11" in result
        mock_run.assert_called_once_with(
            "scan", ["--inline-rules", yaml_rule, "--json", "/test/path"]
        )

    @patch("main.run_ast_grep")
    def test_json_format(self, mock_run):
        """Test JSON format output"""
        mock_result = Mock()
        mock_matches = [{"text": "class Foo:", "file": "test.py"}]
        mock_result.stdout = json.dumps(mock_matches)
        mock_run.return_value = mock_result

        yaml_rule = """id: test
language: python
rule:
  pattern: 'class $NAME'
"""

        result = find_code_by_rule(
            project_folder="/test/path", yaml_rule=yaml_rule, output_format="json"
        )

        assert result == mock_matches
        mock_run.assert_called_once_with(
            "scan", ["--inline-rules", yaml_rule, "--json", "/test/path"]
        )


class TestRunCommand:
    """Test the run_command function"""

    @patch("subprocess.run")
    def test_successful_command(self, mock_run):
        """Test successful command execution"""
        mock_result = Mock()
        mock_result.returncode = 0
        mock_result.stdout = "output"
        mock_run.return_value = mock_result

        result = run_command(["echo", "test"])

        assert result.stdout == "output"
        mock_run.assert_called_once_with(
            ["echo", "test"], capture_output=True, input=None, text=True, check=True, shell=False
        )

    @patch("subprocess.run")
    def test_command_failure(self, mock_run):
        """Test command execution failure"""
        mock_run.side_effect = subprocess.CalledProcessError(
            1, ["false"], stderr="error message"
        )

        with pytest.raises(main.AstGrepExecutionError, match="failed with exit code 1"):
            run_command(["false"])

    @patch("subprocess.run")
    def test_command_not_found(self, mock_run):
        """Test when command is not found"""
        mock_run.side_effect = FileNotFoundError()

        with pytest.raises(main.AstGrepNotFoundError, match="not found"):
            run_command(["nonexistent"])


class TestFormatMatchesAsText:
    """Test the format_matches_as_text helper function"""

    def test_empty_matches(self):
        """Test with empty matches list"""
        result = format_matches_as_text([])
        assert result == ""

    def test_single_line_match(self):
        """Test formatting a single-line match"""
        matches = [
            {
                "text": "const x = 1",
                "file": "test.js",
                "range": {"start": {"line": 4}, "end": {"line": 4}}
            }
        ]
        result = format_matches_as_text(matches)
        assert result == "test.js:5\nconst x = 1"

    def test_multi_line_match(self):
        """Test formatting a multi-line match"""
        matches = [
            {
                "text": "def foo():\n    return 42",
                "file": "test.py",
                "range": {"start": {"line": 9}, "end": {"line": 10}}
            }
        ]
        result = format_matches_as_text(matches)
        assert result == "test.py:10-11\ndef foo():\n    return 42"

    def test_multiple_matches(self):
        """Test formatting multiple matches"""
        matches = [
            {
                "text": "match1",
                "file": "file1.py",
                "range": {"start": {"line": 0}, "end": {"line": 0}}
            },
            {
                "text": "match2\nline2",
                "file": "file2.py",
                "range": {"start": {"line": 5}, "end": {"line": 6}}
            }
        ]
        result = format_matches_as_text(matches)
        expected = "file1.py:1\nmatch1\n\nfile2.py:6-7\nmatch2\nline2"
        assert result == expected


class TestRunAstGrep:
    """Test the run_ast_grep function"""

    @patch("main.run_command")
    @patch("main.CONFIG_PATH", None)
    def test_without_config(self, mock_run):
        """Test running ast-grep without config"""
        mock_result = Mock()
        mock_run.return_value = mock_result

        result = run_ast_grep("run", ["--pattern", "test"])

        assert result == mock_result
        mock_run.assert_called_once_with(["ast-grep", "run", "--pattern", "test"], None)

    @patch("main.run_command")
    @patch("main.CONFIG_PATH", "/path/to/config.yaml")
    def test_with_config(self, mock_run):
        """Test running ast-grep with config"""
        mock_result = Mock()
        mock_run.return_value = mock_result

        result = run_ast_grep("scan", ["--inline-rules", "rule"])

        assert result == mock_result
        mock_run.assert_called_once_with(
            [
                "ast-grep",
                "scan",
                "--config",
                "/path/to/config.yaml",
                "--inline-rules",
                "rule",
            ],
            None,
        )


class TestConfigValidation:
    """Test the validate_config_file function"""

    def test_valid_config(self):
        """Test validating a valid config file"""
        from main import validate_config_file
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")
        config_path = os.path.join(fixtures_dir, "valid_config.yaml")

        # Should not raise an exception
        config = validate_config_file(config_path)
        assert config is not None
        assert config.ruleDirs == ["rules", "custom-rules"]
        assert config.testDirs == ["tests"]
        assert "mylang" in config.customLanguages
        assert ".ml" in config.customLanguages["mylang"].extensions

    def test_invalid_config_extensions(self):
        """Test config with invalid extensions (missing dots)"""
        from main import validate_config_file, ConfigurationError
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")
        config_path = os.path.join(fixtures_dir, "invalid_config_extensions.yaml")

        with pytest.raises(ConfigurationError, match="must start with a dot"):
            validate_config_file(config_path)

    def test_invalid_config_empty_lists(self):
        """Test config with empty lists"""
        from main import validate_config_file, ConfigurationError
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")
        config_path = os.path.join(fixtures_dir, "invalid_config_empty.yaml")

        with pytest.raises(ConfigurationError, match="cannot be empty"):
            validate_config_file(config_path)

    def test_config_file_not_found(self):
        """Test with non-existent config file"""
        from main import validate_config_file, ConfigurationError

        with pytest.raises(ConfigurationError, match="does not exist"):
            validate_config_file("/nonexistent/path/to/config.yaml")

    def test_config_file_is_directory(self):
        """Test with directory instead of file"""
        from main import validate_config_file, ConfigurationError
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")

        with pytest.raises(ConfigurationError, match="not a file"):
            validate_config_file(fixtures_dir)

    def test_config_yaml_parsing_error(self):
        """Test config with YAML syntax error"""
        from main import validate_config_file, ConfigurationError
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")
        config_path = os.path.join(fixtures_dir, "invalid_config_yaml_error.yaml")

        with pytest.raises(ConfigurationError, match="YAML parsing failed"):
            validate_config_file(config_path)

    def test_config_empty_file(self):
        """Test config with empty file"""
        from main import validate_config_file, ConfigurationError
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")
        config_path = os.path.join(fixtures_dir, "empty_config.yaml")

        with pytest.raises(ConfigurationError, match="empty"):
            validate_config_file(config_path)

    def test_config_not_dictionary(self):
        """Test config that is not a dictionary"""
        from main import validate_config_file, ConfigurationError
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")
        config_path = os.path.join(fixtures_dir, "invalid_config_not_dict.yaml")

        with pytest.raises(ConfigurationError, match="must be a YAML dictionary"):
            validate_config_file(config_path)


class TestGetSupportedLanguages:
    """Test the get_supported_languages function"""

    @patch("main.CONFIG_PATH", None)
    def test_without_config(self):
        """Test getting languages without config file"""
        from main import get_supported_languages

        languages = get_supported_languages()

        # Should have all built-in languages
        assert "python" in languages
        assert "javascript" in languages
        assert "rust" in languages
        assert len(languages) >= 24  # At least 24 built-in languages

    @patch("main.CONFIG_PATH")
    def test_with_custom_languages(self, mock_config_path):
        """Test getting languages with custom languages in config"""
        from main import get_supported_languages

        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")
        config_path = os.path.join(fixtures_dir, "config_with_custom_lang.yaml")
        mock_config_path.__bool__ = lambda x: True
        mock_config_path.__str__ = lambda x: config_path

        # Mock os.path.exists to return True for the config path
        with patch("os.path.exists", return_value=True):
            # Re-import to get fresh module state
            import importlib
            import main
            importlib.reload(main)

            # Set CONFIG_PATH
            main.CONFIG_PATH = config_path

            languages = main.get_supported_languages()

            # Should have built-in plus custom languages
            assert "python" in languages
            assert "customlang1" in languages
            assert "customlang2" in languages

    @patch("main.CONFIG_PATH", "/nonexistent/path.yaml")
    @patch("os.path.exists", return_value=False)
    def test_with_nonexistent_config(self, mock_exists):
        """Test with config path that doesn't exist"""
        from main import get_supported_languages

        languages = get_supported_languages()

        # Should still return built-in languages
        assert "python" in languages
        assert len(languages) >= 24

    @patch("main.CONFIG_PATH")
    def test_with_config_exception(self, mock_config_path):
        """Test when config file reading raises exception"""
        from main import get_supported_languages

        mock_config_path.__bool__ = lambda x: True
        mock_config_path.__str__ = lambda x: "/some/path.yaml"

        with patch("os.path.exists", return_value=True):
            with patch("builtins.open", side_effect=OSError("Permission denied")):
                languages = get_supported_languages()

                # Should gracefully handle exception and return built-in languages
                assert "python" in languages
                assert len(languages) >= 24


class TestCustomLanguageConfig:
    """Test CustomLanguageConfig Pydantic model"""

    def test_empty_extensions_list(self):
        """Test that empty extensions list raises error"""
        from main import CustomLanguageConfig
        from pydantic import ValidationError

        with pytest.raises(ValidationError, match="extensions list cannot be empty"):
            CustomLanguageConfig(extensions=[])

    def test_valid_extensions(self):
        """Test valid extensions"""
        from main import CustomLanguageConfig

        config = CustomLanguageConfig(
            extensions=[".ml", ".mli"],
            languageId="mylang"
        )
        assert config.extensions == [".ml", ".mli"]
        assert config.languageId == "mylang"


class TestFormatMatchesEdgeCases:
    """Test edge cases for format_matches_as_text"""

    def test_missing_file_field(self):
        """Test match with missing file field"""
        from main import format_matches_as_text

        matches = [{
            "range": {"start": {"line": 0}, "end": {"line": 0}},
            "text": "test"
        }]
        result = format_matches_as_text(matches)
        assert ":1\ntest" in result

    def test_missing_range_field(self):
        """Test match with missing range field"""
        from main import format_matches_as_text

        matches = [{
            "file": "test.py",
            "text": "test"
        }]
        result = format_matches_as_text(matches)
        assert "test.py:1\ntest" in result

    def test_missing_text_field(self):
        """Test match with missing text field"""
        from main import format_matches_as_text

        matches = [{
            "file": "test.py",
            "range": {"start": {"line": 5}, "end": {"line": 5}}
        }]
        result = format_matches_as_text(matches)
        assert "test.py:6" in result


class TestFindCodeEdgeCases:
    """Test edge cases for find_code function"""

    @patch("main.run_ast_grep")
    def test_find_code_with_language(self, mock_run):
        """Test find_code with language specified"""
        mock_result = Mock()
        mock_result.stdout = "[]"
        mock_run.return_value = mock_result

        result = find_code(
            project_folder="/test",
            pattern="test",
            language="python",
            output_format="text"
        )

        assert result == "No matches found"
        # Verify --lang flag was passed
        call_args = mock_run.call_args[0][1]
        assert "--lang" in call_args
        assert "python" in call_args

    @patch("main.run_ast_grep")
    def test_find_code_without_language(self, mock_run):
        """Test find_code without language (auto-detect)"""
        mock_result = Mock()
        mock_result.stdout = json.dumps([{
            "file": "test.py",
            "range": {"start": {"line": 0}, "end": {"line": 0}},
            "text": "test"
        }])
        mock_run.return_value = mock_result

        result = find_code(
            project_folder="/test",
            pattern="test",
            language="",
            output_format="json"
        )

        # Should return results
        assert len(result) == 1
        # Verify --lang flag was NOT passed
        call_args = mock_run.call_args[0][1]
        assert "--lang" not in call_args


class TestFindCodeByRuleEdgeCases:
    """Test edge cases for find_code_by_rule function"""

    @patch("main.run_ast_grep")
    def test_find_code_by_rule_no_results_text(self, mock_run):
        """Test find_code_by_rule with no results in text format"""
        mock_result = Mock()
        mock_result.stdout = "[]"
        mock_run.return_value = mock_result

        yaml_rule = """
id: test
language: python
rule:
  pattern: test
"""
        result = find_code_by_rule(
            project_folder="/test",
            yaml_rule=yaml_rule,
            output_format="text"
        )

        assert result == "No matches found"

    @patch("main.run_ast_grep")
    def test_find_code_by_rule_invalid_yaml_syntax(self, mock_run):
        """Test find_code_by_rule with invalid YAML syntax"""
        from main import InvalidYAMLError

        # Invalid YAML with unclosed quote
        yaml_rule = 'id: "test\nlanguage: python'

        with pytest.raises(InvalidYAMLError, match="YAML parsing failed"):
            find_code_by_rule(
                project_folder="/test",
                yaml_rule=yaml_rule,
                output_format="text"
            )

    @patch("main.run_ast_grep")
    def test_find_code_by_rule_invalid_output_format(self, mock_run):
        """Test find_code_by_rule with invalid output format"""

        yaml_rule = """
id: test
language: python
rule:
  pattern: test
"""
        with pytest.raises(ValueError, match="Invalid output_format"):
            find_code_by_rule(
                project_folder="/test",
                yaml_rule=yaml_rule,
                output_format="invalid"
            )

    @patch("main.run_ast_grep")
    def test_find_code_by_rule_yaml_not_dict(self, mock_run):
        """Test find_code_by_rule with YAML that's not a dict"""
        from main import InvalidYAMLError

        yaml_rule = "- list\n- of\n- items"

        with pytest.raises(InvalidYAMLError, match="must be a dictionary"):
            find_code_by_rule(
                project_folder="/test",
                yaml_rule=yaml_rule,
                output_format="text"
            )

    @patch("main.run_ast_grep")
    def test_find_code_by_rule_missing_id(self, mock_run):
        """Test find_code_by_rule missing id field"""
        from main import InvalidYAMLError

        yaml_rule = """
language: python
rule:
  pattern: test
"""
        with pytest.raises(InvalidYAMLError, match="Missing required field 'id'"):
            find_code_by_rule(
                project_folder="/test",
                yaml_rule=yaml_rule,
                output_format="text"
            )

    @patch("main.run_ast_grep")
    def test_find_code_by_rule_missing_language(self, mock_run):
        """Test find_code_by_rule missing language field"""
        from main import InvalidYAMLError

        yaml_rule = """
id: test
rule:
  pattern: test
"""
        with pytest.raises(InvalidYAMLError, match="Missing required field 'language'"):
            find_code_by_rule(
                project_folder="/test",
                yaml_rule=yaml_rule,
                output_format="text"
            )

    @patch("main.run_ast_grep")
    def test_find_code_by_rule_missing_rule(self, mock_run):
        """Test find_code_by_rule missing rule field"""
        from main import InvalidYAMLError

        yaml_rule = """
id: test
language: python
"""
        with pytest.raises(InvalidYAMLError, match="Missing required field 'rule'"):
            find_code_by_rule(
                project_folder="/test",
                yaml_rule=yaml_rule,
                output_format="text"
            )

    @patch("main.run_ast_grep")
    def test_find_code_by_rule_with_max_results(self, mock_run):
        """Test find_code_by_rule with max_results limiting"""
        mock_result = Mock()
        # Return 5 matches
        mock_matches = [
            {
                "file": f"test{i}.py",
                "range": {"start": {"line": i}, "end": {"line": i}},
                "text": f"match{i}"
            }
            for i in range(5)
        ]
        mock_result.stdout = json.dumps(mock_matches)
        mock_run.return_value = mock_result

        yaml_rule = """
id: test
language: python
rule:
  pattern: test
"""
        result = find_code_by_rule(
            project_folder="/test",
            yaml_rule=yaml_rule,
            max_results=3,
            output_format="text"
        )

        # Should show only first 3 of 5
        assert "Found 3 matches" in result
        assert "showing first 3 of 5" in result
        assert "test0.py" in result
        assert "test2.py" in result
        assert "test3.py" not in result  # Should not include 4th match


class TestValidateConfigFileErrors:
    """Test error paths in validate_config_file"""

    def test_config_file_read_error(self):
        """Test when file cannot be read (OSError)"""
        from main import validate_config_file, ConfigurationError
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")
        config_path = os.path.join(fixtures_dir, "valid_config.yaml")

        with patch("builtins.open", side_effect=OSError("Permission denied")):
            with pytest.raises(ConfigurationError, match="Failed to read file"):
                validate_config_file(config_path)


class TestYAMLValidation:
    """Test YAML validation in tools"""

    @patch("main.run_ast_grep")
    def test_invalid_yaml_structure(self, mock_run):
        """Test with invalid YAML structure (not a dict)"""
        from main import InvalidYAMLError

        yaml_rule = "- this is a list"

        with pytest.raises(InvalidYAMLError, match="must be a dictionary"):
            match_code_rule("test code", yaml_rule)

    @patch("main.run_ast_grep")
    def test_missing_id_field(self, mock_run):
        """Test YAML missing id field"""
        from main import InvalidYAMLError

        yaml_rule = """
language: python
rule:
  pattern: test
"""
        with pytest.raises(InvalidYAMLError, match="Missing required field 'id'"):
            match_code_rule("test code", yaml_rule)

    @patch("main.run_ast_grep")
    def test_missing_language_field(self, mock_run):
        """Test YAML missing language field"""
        from main import InvalidYAMLError

        yaml_rule = """
id: test
rule:
  pattern: test
"""
        with pytest.raises(InvalidYAMLError, match="Missing required field 'language'"):
            match_code_rule("test code", yaml_rule)

    @patch("main.run_ast_grep")
    def test_missing_rule_field(self, mock_run):
        """Test YAML missing rule field"""
        from main import InvalidYAMLError

        yaml_rule = """
id: test
language: python
"""
        with pytest.raises(InvalidYAMLError, match="Missing required field 'rule'"):
            match_code_rule("test code", yaml_rule)

    @patch("main.run_ast_grep")
    def test_yaml_syntax_error_in_test_match(self, mock_run):
        """Test YAML syntax error in test_match_code_rule"""
        from main import InvalidYAMLError

        # Invalid YAML with syntax error
        yaml_rule = 'id: "unclosed\nlanguage: python'

        with pytest.raises(InvalidYAMLError, match="YAML parsing failed"):
            match_code_rule("test code", yaml_rule)


class TestParseArgsAndGetConfig:
    """Test parse_args_and_get_config function"""

    @patch('sys.argv', ['main.py'])
    @patch('main.CONFIG_PATH', None)
    def test_no_config_provided(self):
        """Test when no config is provided"""
        import importlib
        import main

        # Reload to reset CONFIG_PATH
        importlib.reload(main)

        # Should not raise any errors
        main.parse_args_and_get_config()
        assert main.CONFIG_PATH is None

    @patch('sys.argv', ['main.py', '--config', 'tests/fixtures/valid_config.yaml'])
    def test_with_valid_config_flag(self):
        """Test with valid --config flag"""
        import importlib
        import main

        importlib.reload(main)
        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")
        config_path = os.path.join(fixtures_dir, "valid_config.yaml")

        with patch('sys.argv', ['main.py', '--config', config_path]):
            main.parse_args_and_get_config()
            assert main.CONFIG_PATH == config_path

    @patch('os.environ.get')
    @patch('sys.argv', ['main.py'])
    def test_with_env_var_config(self, mock_env_get):
        """Test with AST_GREP_CONFIG environment variable"""
        import importlib
        import main

        fixtures_dir = os.path.join(os.path.dirname(__file__), "fixtures")
        config_path = os.path.join(fixtures_dir, "valid_config.yaml")

        # Mock environment variable
        def env_side_effect(key, default=None):
            if key == 'AST_GREP_CONFIG':
                return config_path
            return default

        mock_env_get.side_effect = env_side_effect

        importlib.reload(main)
        main.parse_args_and_get_config()
        assert main.CONFIG_PATH == config_path


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
</file>

</files>
